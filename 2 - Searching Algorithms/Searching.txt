BINARY SEARCH:
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

 - process of searching for a specific value in an ordered collection.
 - Time Complexity: O(log(n)) {Best Case: O(1), Worst Case: O(log(n)), Average Case: O(log(n))}, Space Complexity: O(1)

Binary Search is generally composed of 3 main sections:
 - Pre-processing - Sort if collection is unsorted.
 - Binary Search - Using a loop or recursion to divide search space in half after each comparison.
 - Post-processing - Determine viable candidates in the remaining space.

3 MAIN TEMPLATES to BINARY SEARCH PROBLEMS:
1) Case 1: Most Standard Template =>

int binarySearch(int[] nums, int target){
  if(nums == null || nums.length == 0)
    return -1;
  int left = 0, right = nums.length - 1;
  while(left <= right){
    int mid = left + (right - left) / 2;
    if(nums[mid] == target){ return mid; }
    else if(nums[mid] < target) { left = mid + 1; }
    else { right = mid - 1; }
  }
  return -1;
}

 - Most basic and elementary form of Binary Search
 - Search Condition can be determined without comparing to the element's neighbors (or use specific elements around it)
 - No post-processing required because at each step, you are checking to see if the element has been found. If you reach the end, then you know the element is not found

Initial Condition: left = 0, right = length-1
Termination: left > right
Searching Left: right = mid-1
Searching Right: left = mid+1

2) Case 2: Most Standard Template =>
